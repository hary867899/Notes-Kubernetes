Managing Storage 

Persistent storage - persistent means the one which stays... as containers are ephemeral, the storage needs to be persistent... thats why its called as persistent storage 

kubernetes provides storage in 4 ways or 4 api objects ... those are 1.volumes 2. persisent volumes 3. persistent volume claim 4. storage class 
                                                           each one have thier own features 
														  
now, what is important, what will those storages do and how to apply them 

1.volumes :

volumes are given in pod spec section of yaml file. volumes are specific to the pod. so there will be problem in pod re-defnition ... a volume can be any NFS, Azure disk, EBS etc ... if its NFS we need to give server name and IP so that volume is stored there 
i think volumes are used very less in real time as they are pod specific 

2. persisent volume :

we have given volume in pod defnition which is not useful that much for us ... thats why now we are going to give volume at the node level. 

to get persisent volume, we need to write a yml file and give persisent volume in kind [ this is not the case with volume, as said already volumes are given in pod-spec]          

when we give persisent volume which can either be NFS, Block storage in cloud etc etc a volume will be attached to that node for the use 

but the volume will be attached to node ... how we gonna use it, its by persistent volume claim 

3. Persistent-volume claim :

how we can get volume to the pod, up to now, we only wrote some yml file and created a storage for node, so how to do it, it can be done by persistent-voulme claim 

we need to give persistent volume claim in pod-spec file so that it uses the volume that is created. the exact code might be available in nocen demo, please check 

--

access mode - how a node or multiple nodes can access the persistent volume 

three types - 1. ReadWriteOnce 2. ReadWriteMany 3. ReadOnlyMany
                    (RWO)            (RWM)            (ROM)
					
if we give RWO accessmode to Persistent-volume then only one node gets access to that persisent-volume to read and write 
           RWM                                      many nodes 
		   ROM                                      many                                               to read only 
		   
--

nocen explained about static provisioning of volume & dynamic provisioning of persistent volume, dont know what they are but i think dynamic provisioning is what is used by kubernetes users now 

--

configuration of Persistent volume ... the main contents of yml file 

apiVersion : v1 
kind : PersistentVolume
metadata:
  name : nameofvolume
spec:
  capacity:
    storage: 10Gi
  accesmode:
    - ReadWriteMany
nfs:
 server: 172.16.94.55
 path:  "export/volume/path"
  
--
configuration of volume claim we need get if we want to use persistent volume created above 


apiVersion : v1 
kind : PersistentVolumeClaim
metadata:
  name : nameofvolumeclaim
spec:
  capacity:
    storage: 10Gi
  accesmode:
    - ReadWriteMany
 resources:
  requests:
   storage: 5Gi
   
// now we can use 5Gi of persistent volume created above 

--

using the volume claim in pods 

spec: 
  volumes: 
  - name: somename
    PersisentVolumeClaim:
	 claimname: nameofpersistentvolume
  containers:
  - name: nginx
  volumemounts:
  - name: webcontent
    mountpath: "/usr/share/nginx/html/web-app" 

out of all this, what i didnt understand is, so the data that gonna go in to mountpath will be stored in the persisent-volume or not ?? have to know... the answer is yes, the data which either stored by us or generated from container run is stored in that folder... mounting means we are making directory in our folder as the one in another device ... so the app using other device thinks this is the local directory, but the data will come to us because we mounted our directory  

-- 

demo 02 

he explains about the NFS server which our data is stored 

then he demonstrates about how to give static provising and persistent volume etc etc ... 

just go through the demo, if you understand, fine, if you dont understand, die 

---

what is difference between static provisioning and dynamic provisioning 

--

Storage classes 

the difference betweeen static provisioning and dynamic provisioning until now is ... in kind, we need to give storage class... instead of spec we need to give parameters 

apiVersion : storage.k8s.io/v1
kind: StorageClass
metadata:
 name: managed-premium
parameters:
  kind: Managed
  storageaccounttype: Premimum_LRS
provisioner: kubernetes.io/azure-disk

--

apiVersion : v1 
kind : PersistentVolumeClaim
metadata:
  name : nameofvolumeclaim
spec:
  capacity:
    storage: 10Gi
  accesmode:
    - ReadWriteMany
  StorageClassName: namegiveninabovefile
 resources:
  requests:
   storage: 5Gi

the difference observed is we have given paramters instead of spec in dynamic provisioning ... but yet didnt understand the literal meaning 


i think when we create a kubernetes cluster, there will be default storage classes will be provisioned by cluster or nocen already created and showed to them, this dont know 
because nocen didnt show how to create them but there are two storage classes in the cluster in which one is default 

now, in he is showing custom storage class which means two kubernetes storage class will be up for cluster when we creat it 

chat gpt interpretation: static provisioning is provisioning storage manually meaning when we observe persistent volume file more above, in the spec we have given nfs server which would give us storage 
                         while in dynamic provisioning, we just to need to add parameters of the storage we need.. the demo showed by nocen is in AKS, so when we give just parametes, it will automatically creates some storage for us in azure disk while with static we need to create it manually and give details so that it can connect ... we can do it on-prem too, but nocen didnt show it 
						 
						 
--------------------------------------


Configuration as Data- Env variables, secrets and config maps 


Why do we need configuration as data - first of all what is meant by configuration as data... may be giving the configuration of app or workload as an outside data is what i feel 

then now, why do we need it - decoupling pod from configuration helps for the app in many cases, to secure the sensitive info etc etc and nocen explained many reasons, you didnt understand but you understood the outline, so, lets go 

--

we can configure application in pod in three ways ... 1. Command line arguments
                                                      2. Env. Variables
													  3. Config maps 
													  
we will leave the command line arguments as they are used much in real-time scenario 

now, coming to env.vraibles they are two types: user-defined & system-defined ... they shud be defined in the spec of the pod yml file. they are just particular to that pod and container inside it. 

eg:

spec:
  containers:
  - name: hello-world
    image: someimage
    env:
    - name: DATABASE_SERVERNAME
	  value:"sql.example.local"
	- name: BACKEND_SERVERNAME
      value: "be.example.local"	// didnt understand what is this be.example.local
	  
--

demo 03 vscode ... please check 

----

Secrets 

Secrets is an API object which stores sensitive info in a base64 coded format... if you want encryption of secret rather base64 coded, we can configure ... all this stores in 'etcd', so need to make sure etcd is protected 

secrets are namespaced, so only pods with in the namespace specification can use secrets, if secret is attached to pod but not found, the pod wont start 

three types of secrets are available in kubernetes : 1. Docker-registry
                                                     2. generic
													 3. tls 
													 
eg to create a secret // kubectl create secret generic app1 --from-literal=USERNAME=app1login --from-literal=PASSWORD='ucdwcjkdsc' // generic creates a secret either from a local file or local directory or if specified in command line ... the eg command is a secret created from command line 
                                                                                                                                      we can use this secrets in pods as env. variables 

there are two ways in which we can expose a secret 1. env.variables
                                                   2. as volumes or files [ this is used in the real time scenario as its more flexible, so we shud concentrate on it ]

now first see, how secret is used as env. variables ... just go through eg code given below 

spec:
  container:
  - name: hello-world
    ...
	env:
	- name: somename
      valueFrom:
        secretKeyRef:
          name: app1
          key: USERNAME	
    - name: somename2
      valueFrom:
        secretKeyRef:
          name: app1
          key: PASSWORD   // totally we have two sample codes for env. variables.. one which up above declares directly to the pod at that moment
                                                                                   one which is here which the variable is created from the secret we have imperatively created just above 		  

the above length is too long, this can be shortened 

spec:
  container:
  - name: hello-world
    ...
	envFrom:
	- secretRef
        name: app1
		
--

now, lets see how secrets can be given as files

spec:
  volumes:
  - name: appconfig 
    secret:
	  secretName: app1
  containers:
  - name: somename
    ...
	volumeMounts:
	- name: appconfig 
	  mountPath: "/etc/appconfig"  // this looks a bit lenghty and more process to give a secret, may be when we have many secrets it might be useful 
	                                  what we did is, first created a volume in a secret name we created impratively 
									  then, we mounted that volume as a file inside container .. so the secret just goes in to the folder inside container 
									  the folder can be anything, not necessarily be the etc 
	  
--	  

as discussed in the first lines of secret, secrets are three types, up to now, we have seen generic, now we gonna see docker-registry secret 

docker-registry is used to access the private registries like docker hub, Azure container Registry, ECR etc etc 

see demo, if you understand, if you dont, die 

---

Config maps 


config maps are the API object which are used to define application specific configuration settings ... what are the eg's of application specific configuration ?? he will explain in demo, please write them down here for the reference 

just like secrets we can give config maps as env.variables & files 

eg to create a config map 

// kubectl create configmap mapname --from-literal=DATABASE_SERVERNAME=sql.example.local --from-literal=BACKEND_SERVERNAME=be.example.local // creates a config map with two values 
                                                                                                                                               but, what if we have many values, we can create config map from a file
// kubectl create configmap mapname --from-file=filename // 

we can create configmap from yml file too 

//

apiVersion: v1
kind: configmap
metadata:
  name: mapname
data:
  DATABASE_SERVERNAME= sql.example.local
  BACKEND_SERVERNAME= be.example.local 

//

the rest is almost same as secrets 

please check demo, you will understand, if you dont, die 

------------------------------------------------

SCHEDULING 

default scheduler in kubernetes - kube scheduler 

scheduling done on two basis  1. resources 2. policy 

resources is just the avaialble physical resources.. lets say a pod need to be run on certain node, but what if there is no memory or CPU cannot process it .... based on this, scheduler schedules a pod to node

a policy given by us ... lets say we want a certain pod in only node3.. we need to give policy, how to give that policy ??? dont know 

--

Controlling Scheduling 

we can control scheduling in 6 ways ... they are 

1. Node selector     - sometimes we need some pods running on certain nodes, node selector is used for that ... how it can be done ... we can assign labels to nodes... and we can assign pods to that certain node using the match labels in pod spec.  
2. Affinity          - just like nodeselector, we can give labels here too ... but for matching, we will use matchingexpressions other than matchlabels 
                   
                       eg code for affinity 
				       
					   spec:
				         containers:
					     - name: somename
					     ...
					     affinity:
					       podAffinity:
					         requiredDuringSchedulingIgnoreDuringExecution:
						    - labelselector:
						        matchexpressions:
					            - key: app
					              operator: IN
				                  values:
		                          - hello-world-web
						      topologyKey: "kubernetes.io/hostname"              
							  
					    // may be this key, operator, values are given when we create an Affinity just like when we created down on the taints and tolerations 
						  
3. Taints & Tolerations - lets directly start with eg 
                          
						  // kubectl taint nodes c1-node1 key=MyTaint:NoSchedule 
						  so what this command does is it stops pods from scheduling on this node, if we need pods to this node, we need to define tolerations ... then only scheduling will happen 
						  note that if there are pods running already, they continue to run without any effect 
						  
						  eg code 
						  
						  spec:
				         containers:
					     - name: somename
						 ...
						 tolerations:
						 - key: "key"
						   operator: "Equal"
						   value: "MyTaint"
						   effect:"NoSchedule" 
						   
						  // note that, if we give toleration, that does not mean pod shud only run on tainted node, it can run anywhere, its just that we tainted the node but tolerating tbis pod, that does not mean it shud strictly run in here 
						  
watch demo, for both Affinity and Taints and Tolerations ...  you might not understand fully, you need to have a grip of match labels which you ingnored on 'Managing API server and Pods'	course ... watch it again if you needed 

---

		   
						   



























































